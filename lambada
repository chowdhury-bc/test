ws.onmessage = (event) => {
  const rawData = event.data;
  console.log("Raw data received:", typeof rawData, rawData?.substring(0, 50));
  
  // Just display text directly if possible
  try {
    // Try decode as base64
    let decodedText;
    try {
      decodedText = atob(rawData);
      console.log("Decoded text:", decodedText?.substring(0, 50));
    } catch (e) {
      console.log("Not base64, using as-is");
      props.onSendMessage?.(rawData, ChatMessageType.AI);
      return;
    }
    
    // Try to find a text field without full JSON parsing
    if (decodedText.includes('"text"')) {
      const textMatch = decodedText.match(/"text"\s*:\s*"([^"]*)"/) || 
                       decodedText.match(/"text"\s*:\s*"([^"]*)$/);
      
      if (textMatch && textMatch[1]) {
        const textContent = textMatch[1].replace(/\\"/g, '"').replace(/\\n/g, '\n');
        console.log("Extracted text:", textContent);
        
        if (textContent === "ack-end-of-msg") {
          setDisabled(false);
          return;
        }
        
        // Accumulate and display
        msgs = msgs ? msgs + textContent : textContent;
        props.onSendMessage?.(msgs, ChatMessageType.AI);
        return;
      }
    }
    
    // Fallback - just show the decoded text
    props.onSendMessage?.(decodedText, ChatMessageType.AI);
    
  } catch (error) {
    console.error("Processing error:", error);
    props.onSendMessage?.("Error processing message", ChatMessageType.AI);
    setDisabled(false);
  }
};
