ws.onmessage = (event) => {
  try {
    console.log("Raw message received:", event.data.substring(0, 100));
    
    // ALL messages from the Lambda are base64 encoded
    const decodedData = atob(event.data);
    console.log("Decoded data:", decodedData.substring(0, 100));
    
    // Parse the JSON
    const chat_output = JSON.parse(decodedData);
    console.log("Parsed JSON:", chat_output);
    
    // Handle text chunks
    if ('text' in chat_output) {
      const textChunk = chat_output.text;
      
      // Handle end marker
      if (textChunk === "ack-end-of-msg") {
        setDisabled(false);
        return;
      }
      
      // Accumulate text chunks
      if (msgs === null) {
        msgs = textChunk;
      } else {
        msgs += textChunk;
      }
      
      // Display the accumulated text
      props.onSendMessage?.(msgs, ChatMessageType.AI);
    } 
    // Handle other message types
    else if ('intermediate_execution' in chat_output) {
      console.log("Agent execution:", chat_output.intermediate_execution);
    }
    else if ('prompt_flow' in chat_output) {
      agent_prompt_flow = chat_output.prompt_flow;
      if (chat_output.done) {
        setDisabled(false);
      }
    }
    else {
      console.log("Other message type:", chat_output);
      props.onSendMessage?.(JSON.stringify(chat_output), ChatMessageType.AI);
      setDisabled(false);
    }
  } catch (error) {
    console.error("Error processing message:", error);
    props.onSendMessage?.("Error processing response", ChatMessageType.AI);
    setDisabled(false);
  }
};
