ws.onmessage = (event) => {
  try {
    console.log("Raw message received:", typeof event.data, event.data.substring ? event.data.substring(0, 50) : "Non-string data");
    
    if (typeof event.data === 'string' && event.data.includes('message')) {
      const evt_json = JSON.parse(event.data);
      props.onSendMessage?.(evt_json['message'], ChatMessageType.AI);
    }
    else if (typeof event.data === 'string') {
      try {
        const decodedData = atob(event.data);
        console.log("Decoded data:", decodedData.substring(0, 50));
        
        const chat_output = JSON.parse(decodedData);
        
        if ('text' in chat_output) {
          const textChunk = chat_output['text'];
          console.log("Text chunk:", textChunk);
          
          if (textChunk.includes('ack-end-of-msg')) {
            const cleanedText = textChunk.replace('ack-end-of-msg', '');
            if (cleanedText) {
              props.onSendMessage?.(cleanedText, ChatMessageType.AI);
            }
            setTimeout(() => setDisabled(false), 3000);
          } else {
            props.onSendMessage?.(textChunk, ChatMessageType.AI);
          }
        } else if ('intermediate_execution' in chat_output) {
          // Handle agent execution updates
          console.log("Agent execution:", chat_output.intermediate_execution);
        } else if ('prompt_flow' in chat_output && chat_output.done) {
          // Handle completed conversation
          setDisabled(false);
        } else {
          console.log("Other output:", chat_output);
          props.onSendMessage?.(JSON.stringify(chat_output), ChatMessageType.AI);
          setDisabled(false);
        }
      } catch (e) {
        console.error("Processing error:", e);
        props.onSendMessage?.("Error processing response", ChatMessageType.AI);
        setDisabled(false);
      }
    }
  } catch (error) {
    console.error("WebSocket error:", error);
    props.onSendMessage?.("Error processing message", ChatMessageType.AI);
    setDisabled(false);
  }
};
